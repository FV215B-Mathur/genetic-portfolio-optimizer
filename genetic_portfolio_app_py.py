# -*- coding: utf-8 -*-
"""genetic_portfolio_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ORbT_h5wuvtdFzV-C6CCaT8X0CIp4EVA
"""

import streamlit as st
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random

# ---------------------------- GA CORE FUNCTIONS ----------------------------

def get_portfolio_performance(weights, returns):
    port_return = np.sum(returns.mean() * weights) * 252
    port_volatility = np.sqrt(np.dot(weights.T, np.dot(returns.cov(), weights))) * np.sqrt(252)
    return port_return / port_volatility

def initialize_population(pop_size, num_assets):
    return [np.random.dirichlet(np.ones(num_assets)) for _ in range(pop_size)]

def crossover(p1, p2):
    alpha = np.random.rand()
    child = alpha * p1 + (1 - alpha) * p2
    return child / np.sum(child)

def mutate(weights, mutation_rate=0.1):
    if np.random.rand() < mutation_rate:
        idx = np.random.randint(len(weights))
        weights[idx] += np.random.normal(0, 0.1)
        weights = np.abs(weights)
        weights /= np.sum(weights)
    return weights

def select_mating_pool(population, fitnesses, num_parents):
    selected = np.argsort(fitnesses)[-num_parents:]
    return [population[i] for i in selected]

def evolve_population(population, returns, num_parents=10, mutation_rate=0.1):
    fitnesses = [get_portfolio_performance(ind, returns) for ind in population]
    parents = select_mating_pool(population, fitnesses, num_parents)
    children = []

    for _ in range(len(population) - num_parents):
        p1, p2 = random.sample(parents, 2)
        child = crossover(p1, p2)
        child = mutate(child, mutation_rate)
        children.append(child)

    return parents + children, fitnesses

def run_ga(returns, generations=100, population_size=50, num_parents=10):
    num_assets = returns.shape[1]
    population = initialize_population(population_size, num_assets)

    for _ in range(generations):
        population, fitnesses = evolve_population(population, returns, num_parents)

    best_idx = np.argmax(fitnesses)
    return population[best_idx]

# ---------------------------- STREAMLIT UI ----------------------------

st.set_page_config(page_title="Genetic Portfolio Optimizer", layout="wide")
st.title("ð“„€ Agenetic AI: Portfolio Optimization App")

tickers = st.sidebar.text_input("Enter comma-separated tickers:", "AAPL,MSFT,GOOGL,AMZN,NVDA").split(",")
tickers = [ticker.strip().upper() for ticker in tickers]

rebalance_months = st.sidebar.selectbox("Rebalance every:", [1, 3, 6])
training_window_months = st.sidebar.slider("Training window (months):", 6, 36, 12)

start_date = "2020-01-01"
end_date = "2024-12-31"

if st.sidebar.button("Run Optimization"):
    data = yf.download(tickers, start=start_date, end=end_date)['Close']
    data.dropna(inplace=True)
    returns = data.pct_change().dropna()

    rebalance_dates = pd.date_range(start=start_date, end=end_date, freq=f'{rebalance_months}ME')
    portfolio_returns_rolling = []
    weight_snapshots = []

    for start_date in rebalance_dates:
        end_train = start_date + pd.DateOffset(months=training_window_months)
        train_data = returns.loc[start_date:end_train]

        if train_data.shape[0] < 50:
            continue

        best_weights = run_ga(train_data)
        weight_snapshots.append(best_weights)

        future_start = end_train
        future_end = future_start + pd.DateOffset(months=rebalance_months)
        future_returns = returns.loc[future_start:future_end]

        weighted_returns = future_returns @ best_weights
        portfolio_returns_rolling.append(weighted_returns)

    if portfolio_returns_rolling:
        total_returns = pd.concat(portfolio_returns_rolling).sort_index()
        cumulative_returns = (1 + total_returns).cumprod()

        st.subheader("ðŸ“ˆ Cumulative Returns")
        st.line_chart(cumulative_returns)

        final_return = cumulative_returns[-1] - 1
        max_drawdown = (cumulative_returns / cumulative_returns.cummax() - 1).min()

        sorted_r = np.sort(total_returns)
        var_index = int(0.05 * len(sorted_r))
        var = abs(sorted_r[var_index])
        cvar = abs(sorted_r[:var_index].mean())

        st.subheader("ðŸ“Š Key Metrics")
        col1, col2, col3, col4 = st.columns(4)
        col1.metric("Final Return", f"{final_return:.2%}")
        col2.metric("Max Drawdown", f"{max_drawdown:.2%}")
        col3.metric("VaR (95%)", f"-{var:.2%}")
        col4.metric("CVaR", f"-{cvar:.2%}")

        st.subheader("ðŸ’¼ Final Portfolio Allocation")
        final_weights = pd.Series(weight_snapshots[-1], index=tickers)
        st.bar_chart(final_weights)

        st.download_button("Download Portfolio Weights (CSV)", final_weights.to_csv(), "portfolio_weights.csv")
    else:
        st.error("Not enough data to complete optimization.")
